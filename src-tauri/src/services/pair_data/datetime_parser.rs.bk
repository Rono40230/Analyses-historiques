// services/pair_data/datetime_parser.rs - Parser de dates/timestamps
// Conforme .clinerules : < 100L, pas d'unwrap()

use chrono::{DateTime, NaiveDateTime, Utc};

/// Parser de dates et timestamps
pub(super) struct DateTimeParser;

impl DateTimeParser {
    /// Parse une datetime string en timestamp Unix
    pub(super) fn parse(datetime_str: &str) -> Result<i64, String> {
        // Format: 2024.01.01 12:00 ou 2024-01-01 12:00:00
        let cleaned = datetime_str.replace(".", "-").replace("/", "-");

        // Essayer plusieurs formats
        let formats = vec![
            "%Y-%m-%d %H:%M:%S",
            "%Y-%m-%d %H:%M",
            "%Y-%m-%d",
            "%d-%m-%Y %H:%M:%S",
            "%d-%m-%Y %H:%M",
            "%d-%m-%Y",
        ];

        for format in formats {
            if let Ok(dt) = NaiveDateTime::parse_from_str(&cleaned, format) {
                let datetime_utc = DateTime::<Utc>::from_naive_utc_and_offset(dt, Utc);
                return Ok(datetime_utc.timestamp());
            }
        }

        Err(format!("Format datetime non reconnu: {}", datetime_str))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_datetime_formats() {
        assert!(DateTimeParser::parse("2024-01-01 12:00:00").is_ok());
        assert!(DateTimeParser::parse("2024.01.01 12:00").is_ok());
        assert!(DateTimeParser::parse("2024-01-01").is_ok());
    }

    #[test]
    fn test_parse_datetime_invalid() {
        assert!(DateTimeParser::parse("invalid").is_err());
    }
}
