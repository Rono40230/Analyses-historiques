use rusqlite::Connection;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct PastEvent {
    pub id: i32,
    pub name: String,
    pub datetime: String,
    pub country: String,
    pub currency: String,
    pub impact: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct EventType {
    pub name: String,
    pub count: i32,
    pub impact: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EventTypesByImpact {
    pub high: Vec<EventType>,
    pub medium: Vec<EventType>,
}

#[tauri::command]
pub async fn get_past_events(
    _months_back: Option<i32>,
    calendar_id: Option<i32>,
) -> Result<EventTypesByImpact, String> {
    let data_dir = dirs::data_local_dir()
        .ok_or("Failed to get data directory")?
        .join("volatility-analyzer");

    let db_path = data_dir.join("volatility.db");

    if !db_path.exists() {
        return Err("Database not found".to_string());
    }

    let conn = Connection::open(&db_path).map_err(|e| format!("Failed to open database: {}", e))?;

    // Grouper par description (type d'événement) et compter les occurrences
    // Normaliser les impacts: H/M/L/N → HIGH/MEDIUM/LOW/MEDIUM
    // Filtrer par calendar_id si fourni
    // Afficher tous les événements HIGH et MEDIUM (toute la période)
    let query = if let Some(cal_id) = calendar_id {
        format!(
            "SELECT description, COUNT(*) as count, 
                    CASE UPPER(impact)
                        WHEN 'H' THEN 'HIGH'
                        WHEN 'HIGH' THEN 'HIGH'
                        WHEN 'M' THEN 'MEDIUM'
                        WHEN 'MEDIUM' THEN 'MEDIUM'
                        WHEN 'N' THEN 'MEDIUM'
                        WHEN 'L' THEN 'LOW'
                        WHEN 'LOW' THEN 'LOW'
                        ELSE 'MEDIUM'
                    END as normalized_impact
             FROM calendar_events 
             WHERE (UPPER(impact) IN ('H', 'HIGH', 'M', 'MEDIUM', 'N')) AND calendar_import_id = {}
             GROUP BY description, normalized_impact
             ORDER BY count DESC, description",
            cal_id
        )
    } else {
        "SELECT description, COUNT(*) as count, 
                CASE UPPER(impact)
                    WHEN 'H' THEN 'HIGH'
                    WHEN 'HIGH' THEN 'HIGH'
                    WHEN 'M' THEN 'MEDIUM'
                    WHEN 'MEDIUM' THEN 'MEDIUM'
                    WHEN 'N' THEN 'MEDIUM'
                    WHEN 'L' THEN 'LOW'
                    WHEN 'LOW' THEN 'LOW'
                    ELSE 'MEDIUM'
                END as normalized_impact
         FROM calendar_events 
         WHERE UPPER(impact) IN ('H', 'HIGH', 'M', 'MEDIUM', 'N')
         GROUP BY description, normalized_impact
         ORDER BY count DESC, description"
            .to_string()
    };

    let mut stmt = conn
        .prepare(&query)
        .map_err(|e| format!("Failed to prepare statement: {}", e))?;

    let events_iter = stmt
        .query_map([], |row| {
            Ok(EventType {
                name: row.get(0)?,   // description
                count: row.get(1)?,  // count
                impact: row.get(2)?, // impact
            })
        })
        .map_err(|e| format!("Failed to query events: {}", e))?;

    let all_events: Vec<EventType> = events_iter
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| format!("Failed to collect events: {}", e))?;

    // Séparer par impact
    let high = all_events
        .iter()
        .filter(|e| e.impact == "HIGH")
        .cloned()
        .collect();
    let medium = all_events
        .iter()
        .filter(|e| e.impact == "MEDIUM")
        .cloned()
        .collect();

    Ok(EventTypesByImpact { high, medium })
}
